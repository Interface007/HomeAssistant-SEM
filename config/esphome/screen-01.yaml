substitutions:
  name: screen-01
  friendly_name: Screen 01
  static_ip: 192.168.2.45

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.9.0
  name_add_mac_suffix: false

esp32:
  board: esp32dev
  framework:
    type: arduino

logger: !include ./includes/logger.yaml
api: !include ./includes/api.yaml
ota: !include ./includes/ota.yaml
wifi: !include ./includes/wifi_common.yaml
captive_portal:
web_server: !include ./includes/web.yaml

font:
  - file: "fonts/UbuntuMono-Regular.ttf"
    id: font12
    size: 12
    glyphs:
      ['&', '@', '!', '?', ',', '.', '"', '%', '(', ')', '+', '-', '_', ':', '°', '0',
       '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',
       'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
       'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', 'a', 'b', 'c', 'd', 'e', 'f',
       'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
       'u', 'v', 'w', 'x', 'y', 'z', 'å', 'ä', 'ö', 'ü', 'Ä', 'Ö', 'Ü', '/', '€', '’', 'ß', '³']
 
i2c:
  id: i2c_bus            # ID hinzufügen
  sda: GPIO22
  scl: GPIO23
  scan: true

tca9548a:
  - address: 0x70
    id: multiplex0
    i2c_id: i2c_bus
    channels:
      - bus_id: multiplex0channel0
        channel: 0
      - bus_id: multiplex0channel1
        channel: 1

display:
  - platform: ssd1306_i2c
    model: SSD1306_128X64
    address: 0x3C
    i2c_id: multiplex0channel0
    id: oled_display_0
    lambda: |-
      auto write_mux_channel = [](uint8_t channel) {
        uint8_t data = 1 << channel;
        id(i2c_bus).write(0x70, &data, 1);
      };

      auto print_luften = [&](int y, float value, const char* msg) -> int {
        int mold_risk_threshold = 80;
        
        if (std::isnan(value)) {
          ESP_LOGI("mold", "Sensorwert noch nicht verfügbar");
          return y;  // Nichts zeichnen, y nicht erhöhen
        }
        
        ESP_LOGI("mold", "Sensorwert %s: %f", msg, value);
        if (value > mold_risk_threshold) {
          it.print(0, y, id(font12), msg);
          y += 13;
        }
        return y;
      };

      std::string col1 = "";

      auto y = 0;
      
      if(id(window_bathroom_og_north).state == true) { col1 += "FBA-"; ESP_LOGI("window", "FBA: open"); } else { ESP_LOGI("window", "FBA: closed"); }
      if(id(window_lea_south).state == true)         { col1 += "FLE-"; ESP_LOGI("window", "FLE: open"); } else { ESP_LOGI("window", "FLE: closed"); }
      if(id(window_anna_north).state == true)        { col1 += "FAN-"; ESP_LOGI("window", "FAN: open"); } else { ESP_LOGI("window", "FAN: closed"); }
      if(id(window_anna_west).state == true)         { col1 += "FAW-"; ESP_LOGI("window", "FAW: open"); } else { ESP_LOGI("window", "FAW: closed"); }
      if(id(window_sleep_north).state == true)       { col1 += "FSN-"; ESP_LOGI("window", "FSN: open"); } else { ESP_LOGI("window", "FSN: closed"); }
      if(id(window_bathroom_eg_south).state == true) { col1 += "FLE-"; ESP_LOGI("window", "FLE: open"); } else { ESP_LOGI("window", "FLE: closed"); }
      
      if (col1.length() > 1) { col1.pop_back(); } else { y += 13; col1 = "alle Fenster sind zu"; }
      it.print(0, 00, id(font12), col1.c_str()); 
      y += 15;

      y = print_luften(y, id(rel_humidity_livingroomwall).state, "Lueften: Wohnzimmer");
      y = print_luften(y, id(rel_humidity_leawall).state, "Lueften: Lea");
      y = print_luften(y, id(rel_humidity_annawall).state, "Lueften: Anna");
      y = print_luften(y, id(rel_humidity_bedroomwall).state, "Lueften: Schlafzimmer");
      if (y == 15) { it.print(0, y, id(font12), "Alles in Ordnung :)"); }
  
  - platform: ssd1306_i2c
    model: SSD1306_128X64
    address: 0x3C
    i2c_id: multiplex0channel1
    id: oled_display_1
    lambda: |-
      auto write_mux_channel = [](uint8_t channel) {
        uint8_t data = 1 << channel;
        id(i2c_bus).write(0x70, &data, 1);
      };

      // write_mux_channel(1);
      it.print(10, 10, id(font12), "HELLO");

# --- Sensors ------------------------------------------------------------------
sensor:
  - platform: homeassistant
    id: rel_humidity_livingroomwall
    entity_id: sensor.rel_humidity_livingroomwall
    internal: true
    on_value:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: rel_humidity_bedroomwall
    entity_id: sensor.rel_humidity_bedroomwall
    internal: true
    on_value:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: rel_humidity_annawall
    entity_id: sensor.rel_humidity_annawall
    internal: true
    on_value:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: rel_humidity_leawall
    entity_id: sensor.rel_humidity_leawall
    internal: true
    on_value:
      then:
        - lambda: 'id(oled_display_0).update();'

binary_sensor:
  - platform: homeassistant
    id: window_bathroom_og_north
    entity_id: binary_sensor.bad_og_north_window
    internal: true
    on_state:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: window_lea_south
    entity_id: binary_sensor.bthome_sensor_f2ba_window
    internal: true
    on_state:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: window_anna_north
    entity_id: binary_sensor.bthome_sensor_aeac_window
    internal: true
    on_state:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: window_anna_west
    entity_id: binary_sensor.shelly_blu_door_window_f3b0_window
    internal: true
    on_state:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: window_sleep_north
    entity_id: binary_sensor.bthome_sensor_3e90_window
    internal: true
    on_state:
      then:
        - lambda: 'id(oled_display_0).update();'
  - platform: homeassistant
    id: window_bathroom_eg_south
    entity_id: binary_sensor.bthome_sensor_fae8_window
    internal: true
    on_state:
      then:
        - lambda: 'id(oled_display_0).update();'
